import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Trash2, X, RefreshCw, Share2, SkipForward, AlertTriangle, User, Users, Zap, Plus, LogIn, Play, Copy, MessageSquare, Send, Loader2 } from 'lucide-react';
import { predictDrawing, getCategories } from './services/api';
import { CATEGORY_MAP, FRENCH_TO_ENGLISH } from './data/categoryTranslations';
import * as MultiplayerService from './services/multiplayerService';

// Atomized components
import WelcomeScreen from './components/game/WelcomeScreen';
import GameModeSelection from './components/game/GameModeSelection';
import TransitionOverlay from './components/game/TransitionOverlay';
import MultiplayerFlow from './components/game/MultiplayerFlow';
import GameOverScreen from './components/game/GameOverScreen';
import DrawingScreen from './components/game/DrawingScreen';

// Constants
import {
  TOTAL_ROUNDS_CLASSIC,
  TOTAL_ROUNDS_RACE,
  ROUND_TIME,
  WRONG_GUESSES,
  INITIAL_MOCK_PLAYERS
} from './constants/gameConstants';

// --- MAIN COMPONENT ---
export default function QuickDrawApp() {
  const [gameState, setGameState] = useState('WELCOME'); // WELCOME, MODE_SELECT, LOBBY_FLOW, PLAYING, GAME_OVER
  const [gameMode, setGameMode] = useState('CLASSIC'); // CLASSIC, RACE, TEAM
  const [round, setRound] = useState(1);
  const [currentWord, setCurrentWord] = useState('');
  const [previousWord, setPreviousWord] = useState(''); // Pour √©viter les r√©p√©titions
  const [drawings, setDrawings] = useState([]); 
  const [players, setPlayers] = useState([]);
  
  // Multiplayer state
  const [roomCode, setRoomCode] = useState('');
  const [playerId, setPlayerId] = useState('');
  const [isHost, setIsHost] = useState(false);
  const [gameData, setGameData] = useState(null);
  
  // Liste des mots disponibles - charg√©e depuis l'API
  const [wordsToDrawFr, setWordsToDrawFr] = useState([]);
  const [categoriesLoaded, setCategoriesLoaded] = useState(false);
  
  // Controls the "Curtain" transition overlay during the game
  const [showOverlay, setShowOverlay] = useState(false);
  
  // AI Score for Team mode (persistent across rounds)
  const [globalAiScore, setGlobalAiScore] = useState(0);

  // Charger les cat√©gories depuis l'API au d√©marrage
  useEffect(() => {
    const loadCategories = async () => {
      try {
        const data = await getCategories();
        if (data.categories && data.categories.length > 0) {
          // Convertir les cat√©gories anglaises en fran√ßais
          const wordsFr = data.categories.map(cat => CATEGORY_MAP[cat] || cat);
          setWordsToDrawFr(wordsFr);
          setCategoriesLoaded(true);
          console.log(`‚úÖ Loaded ${data.count} categories from backend`);
        }
      } catch (error) {
        console.error('Failed to load categories:', error);
        // Fallback: utiliser toutes les cat√©gories du fichier
        setWordsToDrawFr(Object.values(CATEGORY_MAP));
        setCategoriesLoaded(true);
      }
    };
    
    loadCategories();
  }, []);

  // Start sequence: Welcome -> Mode Select
  const goToModeSelect = () => {
    setGameState('MODE_SELECT');
  };

  // Mode Select -> Playing (Classic)
  const startClassicGame = () => {
    setGameMode('CLASSIC');
    setRound(1);
    setDrawings([]);
    setPreviousWord(''); // Reset le mot pr√©c√©dent
    setPlayers(INITIAL_MOCK_PLAYERS);
    setRoomCode('');
    setPlayerId('');
    setIsHost(true);
    setGameData(null);
    setGameState('PLAYING');
    prepareRound(1);
  };

  // Mode Select -> Lobby Flow (Race/Team)
  const startMultiplayerGame = (mode) => {
    setGameMode(mode);
    setRound(1);
    setDrawings([]);
    setPreviousWord('');
    setPlayers([]);
    setRoomCode('');
    setPlayerId('');
    setIsHost(false);
    setGameData(null);
    setGameState('LOBBY_FLOW');
  };

  // Handle multiplayer game created/joined
  const handleMultiplayerJoined = useCallback((code, id, host) => {
    setRoomCode(code);
    setPlayerId(id);
    setIsHost(host);
  }, []);

  // Handle game data updates from Firebase
  const handleGameUpdate = useCallback((data) => {
    if (!data) {
      // Game deleted or doesn't exist
      setGameState('MODE_SELECT');
      return;
    }
    
    console.log('üîÑ handleGameUpdate - roundStatus:', data.roundStatus, 'gameState:', gameState, 'aiScore:', data.aiScore);
    setGameData(data);
    
    // Sync AI score from Firebase (TEAM mode)
    if (typeof data.aiScore === 'number') {
      setGlobalAiScore(data.aiScore);
    }
    
    // If roundStatus is 'playing' and we still have overlay, dismiss it
    if (data.roundStatus === 'playing' && showOverlay && gameState === 'PLAYING') {
      console.log('üé¨ Round is playing, dismissing overlay from handleGameUpdate');
      setShowOverlay(false);
    }
    
    // Convert players object to array
    const playersArray = Object.values(data.players || {}).map(p => ({
      ...p,
      id: p.id === playerId ? 'me' : p.id
    })).sort((a, b) => (b.score || 0) - (a.score || 0));
    
    setPlayers(playersArray);
    
    // Handle game state transitions
    if (data.status === 'playing' && gameState === 'LOBBY_FLOW') {
      // Game just started - transition to playing
      setGameState('PLAYING');
      setRound(data.currentRound || 1);
      setCurrentWord(data.currentWord || '');
      setShowOverlay(true);
    } else if (data.status === 'playing' && gameState === 'PLAYING') {
      // Update round info during game
      if (data.currentRound !== round) {
        // New round started
        setRound(data.currentRound);
        setCurrentWord(data.currentWord || '');
        setShowOverlay(true);
      }
      
      // Handle round status changes (waiting -> playing)
      // The overlay will auto-dismiss when roundStatus becomes 'playing'
      if (data.roundStatus === 'playing' && showOverlay) {
        // Round has started, overlay will be dismissed by TransitionOverlay component
        // via the roundStatus prop
      }
    } else if (data.status === 'finished') {
      setGameState('GAME_OVER');
    }
  }, [playerId, gameState, round, showOverlay]);

  // Subscribe to game updates when playing multiplayer
  // This maintains the subscription after transitioning from LOBBY_FLOW to PLAYING
  useEffect(() => {
    if (gameState !== 'PLAYING' || !roomCode || gameMode === 'CLASSIC') {
      return;
    }
    
    console.log('üì° Setting up game subscription for playing state - room:', roomCode);
    
    const unsubscribe = MultiplayerService.subscribeToGame(roomCode, (data) => {
      if (data) {
        console.log('üì• Game update received:', { roundStatus: data.roundStatus, round: data.currentRound });
        handleGameUpdate(data);
      }
    });
    
    return () => {
      console.log('üîå Cleaning up game subscription');
      unsubscribe();
    };
  }, [gameState, roomCode, gameMode, handleGameUpdate]);

  // Lobby Flow -> Playing (start game as host)
  const startGameFromLobby = async () => {
    if (gameMode === 'CLASSIC') {
      setGameState('PLAYING');
      prepareRound(1);
    } else {
      // Multiplayer - start game via Firebase
      try {
        await MultiplayerService.startGame(roomCode, wordsToDrawFr);
        // State will be updated via subscription
      } catch (error) {
        console.error('Error starting game:', error);
        alert('Erreur lors du d√©marrage de la partie');
      }
    }
  };

  // Leave multiplayer game
  const leaveMultiplayerGame = async () => {
    if (roomCode && playerId) {
      try {
        await MultiplayerService.leaveGame(roomCode, playerId);
      } catch (error) {
        console.error('Error leaving game:', error);
      }
    }
    setRoomCode('');
    setPlayerId('');
    setIsHost(false);
    setGameData(null);
    setGameState('MODE_SELECT');
  };

  // Force start round after timeout (5 seconds)
  const handleForceStartRound = useCallback(async () => {
    if (roomCode) {
      try {
        await MultiplayerService.forceStartRound(roomCode);
      } catch (error) {
        console.error('Error force starting round:', error);
      }
    }
  }, [roomCode]);

  const prepareRound = (roundNum) => {
    // Ne pas d√©marrer si les cat√©gories ne sont pas charg√©es
    if (!categoriesLoaded || wordsToDrawFr.length === 0) {
      console.warn('Categories not loaded yet');
      return;
    }
    
    // Choisir un mot diff√©rent du pr√©c√©dent
    let word;
    do {
      word = wordsToDrawFr[Math.floor(Math.random() * wordsToDrawFr.length)];
    } while (word === previousWord && wordsToDrawFr.length > 1);
    
    setCurrentWord(word);
    setPreviousWord(word);
    // Show the curtain overlay for instructions
    setShowOverlay(true);
  };

  const handleRoundComplete = async (imageData, success, winner = null, timeLeft = 0, confidence = 0) => {
    // Calculate points
    let totalPoints = 0;
    const timeBonus = Math.round((timeLeft / ROUND_TIME) * 50);
    const confidenceBonus = Math.round(confidence * 50);
    
    if (success) {
      totalPoints = 100 + timeBonus + confidenceBonus;
    }

    // In multiplayer mode, submit result to Firebase
    if ((gameMode === 'RACE' || gameMode === 'TEAM') && roomCode && playerId) {
      try {
        await MultiplayerService.submitRoundResult(
          roomCode,
          playerId.replace('me', playerId), // Use real player ID
          success,
          confidence,
          timeLeft
        );
        
        // The score update will come from Firebase subscription
        // No need to update local state manually
      } catch (error) {
        console.error('Error submitting round result:', error);
      }
    } else {
      // Classic mode - update scores locally
      if (gameMode === 'RACE' && success) {
        setPlayers(prevPlayers => 
          prevPlayers.map(p => 
            p.id === 'me' ? { ...p, score: p.score + totalPoints } : p
          )
        );
      } else if (gameMode === 'TEAM') {
        // In Team mode, update scores based on winner
        if (winner === 'TEAM') {
          setPlayers(prevPlayers => 
            prevPlayers.map(p => 
              p.id !== 'me' ? { ...p, score: p.score + 5 } : p
            )
          );
        }
      }
    }

    // Save drawing locally
    const newDrawings = [...drawings, { word: currentWord, imageData, success, winner }];
    setDrawings(newDrawings);

    const totalRounds = gameMode === 'RACE' ? TOTAL_ROUNDS_RACE : TOTAL_ROUNDS_CLASSIC;

    // In multiplayer mode, host handles round transitions via Firebase
    if ((gameMode === 'RACE' || gameMode === 'TEAM') && roomCode && isHost) {
      // Wait a bit for other players to submit, then advance round
      setTimeout(async () => {
        try {
          if (round < totalRounds) {
            await MultiplayerService.nextRound(roomCode, wordsToDrawFr);
          } else {
            await MultiplayerService.endGame(roomCode);
          }
        } catch (error) {
          console.error('Error advancing round:', error);
        }
      }, 2000); // Wait 2 seconds for other players
    } else if (gameMode === 'CLASSIC') {
      // Classic mode - handle locally
      if (round < totalRounds) {
        setShowOverlay(false);
        setTimeout(() => {
          setRound(round + 1);
          prepareRound(round + 1);
        }, 600);
      } else {
        setGameState('GAME_OVER');
      }
    }
    // In multiplayer non-host mode, state updates come from Firebase subscription
  };

  // --- RENDER ---
  return (
    <div className="min-h-screen bg-[#ECECEC] font-['Architects_Daughter'] text-[#333] overflow-hidden select-none relative">
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Architects+Daughter&display=swap');
          body { font-family: 'Architects Daughter', cursive; }
          .btn-shadow { box-shadow: 4px 4px 0px 0px rgba(0,0,0,1); }
          .btn-shadow:active { box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); transform: translate(2px, 2px); }
          /* Curtain Animation Classes */
          .curtain-enter { transform: translateY(-100%); }
          .curtain-active { transform: translateY(0); transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
          .curtain-exit { transform: translateY(0); }
          .curtain-exit-active { transform: translateY(-100%); transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        `}
      </style>

      {gameState === 'WELCOME' && <WelcomeScreen onStart={goToModeSelect} />}
      
      {gameState === 'MODE_SELECT' && (
        <GameModeSelection 
          onSelectClassic={startClassicGame}
          onSelectRace={() => startMultiplayerGame('RACE')}
          onSelectTeam={() => startMultiplayerGame('TEAM')}
        />
      )}

      {gameState === 'LOBBY_FLOW' && (
        <MultiplayerFlow
          mode={gameMode}
          onBack={leaveMultiplayerGame}
          onStartGame={startGameFromLobby}
          players={players}
          roomCode={roomCode}
          playerId={playerId}
          isHost={isHost}
          onJoined={handleMultiplayerJoined}
          onGameUpdate={handleGameUpdate}
          wordsToDrawFr={wordsToDrawFr}
        />
      )}

      {/* LOGIC: We keep DrawingScreen mounted during the game. 
        The TransitionOverlay sits ON TOP and slides up/down.
      */}
      {gameState === 'PLAYING' && (
        <>
          <DrawingScreen 
            word={currentWord} 
            round={round}
            gameMode={gameMode}
            players={players}
            totalRounds={gameMode === 'RACE' ? TOTAL_ROUNDS_RACE : TOTAL_ROUNDS_CLASSIC}
            // Pause timer if overlay is visible
            isPaused={showOverlay} 
            onComplete={handleRoundComplete}
            onQuit={() => setGameState('WELCOME')}
            // Team mode props
            roomCode={roomCode}
            playerId={playerId}
            currentDrawerId={gameData?.currentDrawerId}
            gameData={gameData}
            isHost={isHost}
            // AI Score props
            globalAiScore={globalAiScore}
            onAiScoreUpdate={setGlobalAiScore}
          />
          
          <TransitionOverlay 
            isVisible={showOverlay}
            word={currentWord}
            round={round}
            totalRounds={gameMode === 'RACE' ? TOTAL_ROUNDS_RACE : TOTAL_ROUNDS_CLASSIC}
            onDismiss={() => setShowOverlay(false)}
            // Multiplayer props
            isMultiplayer={(gameMode === 'RACE' || gameMode === 'TEAM') && !!roomCode}
            gameMode={gameMode}
            roomCode={roomCode}
            playerId={playerId}
            players={players}
            roundStatus={gameData?.roundStatus || ((gameMode === 'RACE' || gameMode === 'TEAM') && roomCode ? 'waiting' : 'playing')}
            currentDrawerId={gameData?.currentDrawerId}
            onForceStart={handleForceStartRound}
          />
        </>
      )}

      {gameState === 'GAME_OVER' && (
        <GameOverScreen 
          drawings={drawings}
          gameMode={gameMode}
          players={players}
          aiScore={globalAiScore}
          onRestart={goToModeSelect}
        />
      )}
    </div>
  );
}

// --- SUB-COMPONENTS ---

function WelcomeScreen({ onStart }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 text-center z-10 relative">
      <div className="mb-8 relative">
        <h1 className="text-6xl md:text-8xl font-bold tracking-tight text-blue-600">
          Swift, Sketch
        </h1>
        <div className="absolute -top-6 -right-8 transform rotate-12 text-black opacity-10 text-9xl pointer-events-none">
          ‚úé
        </div>
      </div>
      
      <p className="text-2xl md:text-3xl max-w-2xl mb-12 leading-relaxed">
        Un r√©seau de neurones peut-il apprendre √† reconna√Ætre vos gribouillages ?
      </p>
      
      <button 
        onClick={onStart}
        className="btn-shadow bg-blue-600 text-white border-4 border-black text-3xl px-12 py-4 rounded-sm hover:bg-blue-500 transition-colors duration-200 font-bold tracking-wider"
      >
        C'est parti !
      </button>

      <div className="mt-20 text-gray-500 text-sm flex gap-4">
        <span>√Ä propos</span>
        <span>‚Ä¢</span>
        <span>Confidentialit√©</span>
      </div>
    </div>
  );
}

// New Component: Game Mode Selection Curtain
function GameModeSelection({ onSelectClassic, onSelectRace, onSelectTeam }) {
  const [renderState, setRenderState] = useState('hidden');

  useEffect(() => {
    // Start entry animation on mount
    setRenderState('entering');
    setTimeout(() => setRenderState('visible'), 50);
  }, []);

  const getTransformClass = () => {
    if (renderState === 'entering') return 'translate-y-[-100%]';
    if (renderState === 'visible') return 'translate-y-0';
    return 'translate-y-[-100%]';
  };

  return (
    <div 
      className={`fixed inset-0 z-50 flex flex-col items-center justify-center bg-[#ECECEC] transition-transform duration-500 ease-in-out ${getTransformClass()}`}
      style={{ willChange: 'transform' }}
    >
      <div className="bg-white p-8 md:p-12 rounded-sm border-4 border-black text-center shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] max-w-4xl w-full mx-4">
        <h2 className="text-4xl md:text-5xl font-bold mb-8 text-blue-600">Choisissez un mode</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Classic Mode */}
          <button 
            onClick={onSelectClassic}
            className="group flex flex-col items-center p-6 border-4 border-black rounded-sm hover:bg-blue-50 transition-colors btn-shadow bg-white"
          >
            <div className="bg-blue-600 p-4 rounded-full border-2 border-black mb-4 group-hover:scale-110 transition-transform">
               <User size={32} className="text-white" />
            </div>
            <h3 className="text-2xl font-bold mb-2">Classique</h3>
            <p className="text-gray-500 text-sm">Mode Solo. Dessinez 6 objets et d√©fiez l'IA.</p>
          </button>

          {/* Race Mode */}
          <button 
            onClick={onSelectRace}
            className="group flex flex-col items-center p-6 border-4 border-black rounded-sm hover:bg-blue-50 transition-colors btn-shadow bg-white"
          >
             <div className="bg-blue-600 p-4 rounded-full border-2 border-black mb-4 group-hover:scale-110 transition-transform">
               <Zap size={32} className="text-white"/>
            </div>
            <h3 className="text-2xl font-bold mb-2">Course</h3>
            <p className="text-gray-500 text-sm">Multijoueur. Soyez le plus rapide √† faire deviner (6 manches).</p>
          </button>

          {/* Team Mode */}
          <button 
            onClick={onSelectTeam}
            className="group flex flex-col items-center p-6 border-4 border-black rounded-sm hover:bg-blue-50 transition-colors btn-shadow bg-white"
          >
             <div className="bg-blue-600 p-4 rounded-full border-2 border-black mb-4 group-hover:scale-110 transition-transform">
               <Users size={32} className="text-white"/>
            </div>
            <h3 className="text-2xl font-bold mb-2">Team vs IA</h3>
            <p className="text-gray-500 text-sm">Coop. Dessinez ensemble pour battre l'IA.</p>
          </button>
        </div>
      </div>
    </div>
  );
}

// The sliding panel (Curtain) - supports multiplayer sync
function TransitionOverlay({ 
  isVisible, 
  word, 
  round, 
  totalRounds, 
  onDismiss,
  // Multiplayer props
  isMultiplayer = false,
  gameMode = 'CLASSIC',
  roomCode = '',
  playerId = '',
  players = [],
  roundStatus = 'playing', // 'waiting' or 'playing'
  currentDrawerId = null, // For TEAM mode
  onForceStart = null
}) {
  // We use internal state to handle the CSS transition classes
  const [renderState, setRenderState] = useState('hidden'); // hidden, entering, visible, exiting
  const [countdown, setCountdown] = useState(5);
  const [hasClickedReady, setHasClickedReady] = useState(false);
  const countdownStartedRef = useRef(false);
  
  // Check if current player is the drawer (TEAM mode)
  const isDrawer = gameMode === 'TEAM' && currentDrawerId === playerId;
  const isTeamMode = gameMode === 'TEAM';
  
  // Find drawer info
  const drawerPlayer = isTeamMode ? players.find(p => p.id === currentDrawerId || (p.id === 'me' && currentDrawerId === playerId)) : null;

  useEffect(() => {
    if (isVisible) {
      setRenderState('entering');
      setCountdown(5);
      setHasClickedReady(false);
      countdownStartedRef.current = false;
      // Force reflow/next tick to start animation
      setTimeout(() => setRenderState('visible'), 50);
    } else {
      setRenderState('exiting');
      // Wait for animation to finish before hiding completely (if needed)
      const timer = setTimeout(() => setRenderState('hidden'), 500);
      return () => clearTimeout(timer);
    }
  }, [isVisible]);

  // Countdown timer for multiplayer mode
  useEffect(() => {
    if (!isMultiplayer || !isVisible || roundStatus !== 'waiting') return;
    
    // Don't restart if already started
    if (countdownStartedRef.current) return;
    countdownStartedRef.current = true;
    
    console.log('üïê Starting countdown for multiplayer round...');
    setCountdown(5);
    
    const interval = setInterval(() => {
      setCountdown(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          // Force start after countdown
          console.log('‚è∞ Countdown finished, forcing start...');
          if (onForceStart && roomCode) {
            onForceStart();
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [isMultiplayer, isVisible, roundStatus, onForceStart, roomCode]);

  // When round starts (roundStatus changes to 'playing'), dismiss overlay
  useEffect(() => {
    console.log('üéØ TransitionOverlay roundStatus check:', { roundStatus, isMultiplayer, isVisible });
    if (isMultiplayer && roundStatus === 'playing' && isVisible) {
      console.log('‚úÖ Dismissing overlay - roundStatus is playing');
      onDismiss();
    }
  }, [roundStatus, isMultiplayer, isVisible, onDismiss]);
  
  // Fallback: also dismiss when countdown reaches 0 (force start triggered)
  useEffect(() => {
    if (isMultiplayer && countdown === 0 && isVisible) {
      // Give a small delay for Firebase to update, then force dismiss
      const timer = setTimeout(() => {
        console.log('‚ö° Force dismissing overlay after countdown');
        onDismiss();
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [countdown, isMultiplayer, isVisible, onDismiss]);

  const handleReadyClick = async () => {
    console.log('üñ±Ô∏è Ready clicked - isMultiplayer:', isMultiplayer, 'roomCode:', roomCode, 'playerId:', playerId, 'hasClickedReady:', hasClickedReady);
    
    if (isMultiplayer && roomCode && playerId && !hasClickedReady) {
      setHasClickedReady(true);
      try {
        console.log('üì§ Marking player ready:', playerId);
        await MultiplayerService.markPlayerReady(roomCode, playerId);
        console.log('‚úÖ Player marked ready');
      } catch (error) {
        console.error('‚ùå Error marking ready:', error);
        setHasClickedReady(false); // Reset so user can try again
      }
    } else if (!isMultiplayer) {
      // Classic mode - just dismiss
      onDismiss();
    }
  };

  // Determine CSS class based on state
  const getTransformClass = () => {
    if (renderState === 'entering') return 'translate-y-[-100%]';
    if (renderState === 'visible') return 'translate-y-0';
    if (renderState === 'exiting') return 'translate-y-[-100%]';
    return 'translate-y-[-100%]'; // hidden default
  };

  // Count ready players
  const readyCount = players.filter(p => p.isReady).length;
  const totalPlayers = players.length;

  return (
    <div 
      className={`fixed inset-0 z-50 flex items-center justify-center bg-[#ECECEC] transition-transform duration-500 ease-in-out ${getTransformClass()}`}
      style={{ willChange: 'transform' }}
    >
       <div className="bg-white p-10 md:p-14 rounded-sm border-4 border-black text-center shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] max-w-2xl w-full mx-4">
        
        {/* TEAM mode - Different display for drawer vs guessers */}
        {isTeamMode ? (
          <>
            <p className="text-2xl text-gray-500 mb-4">
              Niveau {round}/{totalRounds}
            </p>
            
            {isDrawer ? (
              <>
                <p className="text-lg text-blue-600 font-bold mb-2">üé® C'est √† vous de dessiner !</p>
                <h2 className="text-5xl md:text-6xl font-bold mb-6 capitalize">{word}</h2>
                <p className="text-xl text-gray-500 mb-6">Faites deviner ce mot √† votre √©quipe !</p>
              </>
            ) : (
              <>
                <p className="text-lg text-purple-600 font-bold mb-2">üîÆ Devinez le dessin !</p>
                <div className="flex items-center justify-center gap-2 mb-6">
                  <span className="text-2xl">{drawerPlayer?.avatar || 'üé®'}</span>
                  <span className="text-xl font-bold">{drawerPlayer?.name || 'Un joueur'}</span>
                  <span className="text-xl text-gray-500">dessine...</span>
                </div>
                <h2 className="text-5xl md:text-6xl font-bold mb-6 text-gray-300">? ? ?</h2>
                <p className="text-xl text-gray-500 mb-6">Utilisez le chat pour proposer vos r√©ponses !</p>
              </>
            )}
          </>
        ) : (
          <>
            <p className="text-2xl text-gray-500 mb-4">
              Niveau {round}/{totalRounds} ‚Ä¢ Dessinez :
            </p>
            <h2 className="text-5xl md:text-6xl font-bold mb-10 capitalize">{word}</h2>
            <p className="text-xl text-gray-500 mb-6">en moins de {ROUND_TIME} secondes</p>
          </>
        )}
        
        {/* Multiplayer status */}
        {isMultiplayer && roundStatus === 'waiting' && (
          <div className="mb-6">
            <div className="flex justify-center items-center gap-2 mb-4">
              <div className="flex -space-x-2">
                {players.map(player => (
                  <div 
                    key={player.id} 
                    className={`w-10 h-10 rounded-full border-2 flex items-center justify-center text-lg transition-all ${
                      player.isReady 
                        ? 'border-green-500 bg-green-100' 
                        : 'border-gray-300 bg-gray-100'
                    }`}
                    title={`${player.name} ${player.isReady ? '‚úì' : '...'}`}
                  >
                    {player.avatar}
                  </div>
                ))}
              </div>
              <span className="text-sm font-bold text-gray-500 ml-2">
                {readyCount}/{totalPlayers} pr√™ts
              </span>
            </div>
            {/* Countdown */}
            <div className="text-4xl font-bold text-blue-600 mb-4">
              {countdown > 0 ? countdown : 'üöÄ'}
            </div>
            <p className="text-sm text-gray-400">
              {countdown > 0 
                ? `D√©marrage automatique dans ${countdown}s` 
                : 'D√©marrage...'
              }
            </p>
          </div>
        )}
        
        <button 
          onClick={handleReadyClick}
          disabled={isMultiplayer && hasClickedReady && roundStatus === 'waiting'}
          className={`btn-shadow border-4 border-black text-2xl px-10 py-3 rounded-sm transition-colors w-full md:w-auto font-bold ${
            isMultiplayer && hasClickedReady && roundStatus === 'waiting'
              ? 'bg-green-500 text-white cursor-default'
              : 'bg-blue-600 text-white hover:bg-blue-500'
          }`}
        >
          {isMultiplayer && hasClickedReady && roundStatus === 'waiting' 
            ? '‚úì Pr√™t !' 
            : "C'est parti !"
          }
        </button>
      </div>
    </div>
  );
}

// Multiplayer Flow Component (Lobby & Waiting Room)
function MultiplayerFlow({ mode, onBack, onStartGame, players, roomCode: existingRoomCode, playerId: existingPlayerId, isHost: existingIsHost, onJoined, onGameUpdate, wordsToDrawFr }) {
  const [step, setStep] = useState('LOBBY'); // LOBBY, WAITING_ROOM
  const [localIsHost, setLocalIsHost] = useState(existingIsHost);
  const [localRoomCode, setLocalRoomCode] = useState(existingRoomCode || '');
  const [localPlayerId, setLocalPlayerId] = useState(existingPlayerId || '');
  const [playerName, setPlayerName] = useState('Joueur');
  const [playerEmoji, setPlayerEmoji] = useState('üòé');
  const [availableGames, setAvailableGames] = useState([]);
  const [joinCode, setJoinCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');

  // Liste d'emojis disponibles
  const availableEmojis = ['üòé', 'üò∫', 'ü§ñ', 'ü¶ä', 'üêº', 'üê∏', 'ü¶Å', 'üêØ', 'üê®', 'üêª', 'üé®', 'üéÆ', 'üåü', 'üî•', 'üíé'];

  // Mode specific styles - NOW ALL BLUE
  const themeColor = 'bg-blue-600';
  const themeText = 'text-blue-600';
  const themeHover = 'hover:bg-blue-500';
  
  const modeName = mode === 'RACE' ? 'Mode Course' : 'Team vs IA';
  const modeIcon = mode === 'RACE' ? <Zap size={40} className="text-white" /> : <Users size={40} className="text-white" />;

  // Subscribe to available games list
  useEffect(() => {
    if (step !== 'LOBBY') return;

    const unsubscribe = MultiplayerService.subscribeToAvailableGames(mode, (games) => {
      setAvailableGames(games);
    });

    return () => unsubscribe();
  }, [step, mode]);

  // Subscribe to game updates when in waiting room
  useEffect(() => {
    if (step !== 'WAITING_ROOM' || !localRoomCode) return;

    const unsubscribe = MultiplayerService.subscribeToGame(localRoomCode, (gameData) => {
      if (gameData) {
        onGameUpdate(gameData);
        // Update local host status in case it changed
        setLocalIsHost(gameData.hostId === localPlayerId);
      } else {
        // Game was deleted
        setStep('LOBBY');
        setError('La partie a √©t√© supprim√©e');
      }
    });

    return () => unsubscribe();
  }, [step, localRoomCode, localPlayerId, onGameUpdate]);

  // Heartbeat to keep player online
  useEffect(() => {
    if (step !== 'WAITING_ROOM' || !localRoomCode || !localPlayerId) return;

    const interval = setInterval(() => {
      MultiplayerService.updateHeartbeat(localRoomCode, localPlayerId);
    }, 5000);

    return () => clearInterval(interval);
  }, [step, localRoomCode, localPlayerId]);

  const handleCreateGame = async () => {
    if (!playerName.trim()) {
      setError('Entrez votre nom');
      return;
    }
    
    setIsLoading(true);
    setError('');
    
    try {
      const result = await MultiplayerService.createGame(mode, playerName.trim(), playerEmoji);
      setLocalRoomCode(result.roomCode);
      setLocalPlayerId(result.playerId);
      setLocalIsHost(true);
      onJoined(result.roomCode, result.playerId, true);
      setStep('WAITING_ROOM');
    } catch (err) {
      console.error('Error creating game:', err);
      setError(err.message || 'Erreur lors de la cr√©ation');
    } finally {
      setIsLoading(false);
    }
  };

  const handleJoinGameByCode = async () => {
    if (!playerName.trim()) {
      setError('Entrez votre nom');
      return;
    }
    if (!joinCode.trim()) {
      setError('Entrez le code de la partie');
      return;
    }
    
    setIsLoading(true);
    setError('');
    
    try {
      const result = await MultiplayerService.joinGame(joinCode.toUpperCase().trim(), playerName.trim(), playerEmoji);
      setLocalRoomCode(result.roomCode);
      setLocalPlayerId(result.playerId);
      setLocalIsHost(false);
      onJoined(result.roomCode, result.playerId, false);
      setStep('WAITING_ROOM');
    } catch (err) {
      console.error('Error joining game:', err);
      setError(err.message || 'Erreur lors de la connexion');
    } finally {
      setIsLoading(false);
    }
  };

  const handleJoinExistingGame = async (code) => {
    if (!playerName.trim()) {
      setError('Entrez votre nom d\'abord');
      return;
    }
    
    setIsLoading(true);
    setError('');
    
    try {
      const result = await MultiplayerService.joinGame(code, playerName.trim(), playerEmoji);
      setLocalRoomCode(result.roomCode);
      setLocalPlayerId(result.playerId);
      setLocalIsHost(false);
      onJoined(result.roomCode, result.playerId, false);
      setStep('WAITING_ROOM');
    } catch (err) {
      console.error('Error joining game:', err);
      setError(err.message || 'Erreur lors de la connexion');
    } finally {
      setIsLoading(false);
    }
  };

  const handleLeaveWaitingRoom = async () => {
    if (localRoomCode && localPlayerId) {
      try {
        await MultiplayerService.leaveGame(localRoomCode, localPlayerId);
      } catch (err) {
        console.error('Error leaving game:', err);
      }
    }
    setLocalRoomCode('');
    setLocalPlayerId('');
    setLocalIsHost(false);
    setStep('LOBBY');
  };

  const copyRoomCode = () => {
    navigator.clipboard.writeText(localRoomCode);
  };

  if (step === 'LOBBY') {
    return (
      <div className="min-h-screen flex flex-col items-center pt-12 px-4 bg-[#ECECEC]">
        <div className="w-full max-w-4xl">
          <div className="flex items-center mb-8 relative">
            <button onClick={onBack} className="absolute left-0 p-2 hover:bg-white/50 rounded-full transition-colors"><X size={32} /></button>
            <h2 className={`text-4xl font-bold text-center w-full ${themeText} flex items-center justify-center gap-3`}>
              {mode === 'RACE' ? <Zap size={40} /> : <Users size={40} />} {modeName}
            </h2>
          </div>

          {error && (
            <div className="mb-4 p-4 bg-red-50 border-2 border-red-300 rounded-sm text-red-700 font-bold text-center">
              {error}
            </div>
          )}

          {/* Player Profile Setup */}
          <div className="mb-8 bg-white p-6 rounded-sm border-4 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)]">
            <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
              <User size={24} /> Votre profil
            </h3>
            <div className="flex flex-col md:flex-row gap-4 items-center">
              {/* Emoji Selector */}
              <div className="flex flex-col items-center gap-2">
                <div className="text-6xl">{playerEmoji}</div>
                <div className="flex flex-wrap gap-2 justify-center max-w-xs">
                  {availableEmojis.map(emoji => (
                    <button
                      key={emoji}
                      onClick={() => setPlayerEmoji(emoji)}
                      className={`text-2xl p-1.5 rounded-lg border-2 transition-all hover:scale-110 ${
                        playerEmoji === emoji 
                          ? 'border-blue-600 bg-blue-50 scale-110' 
                          : 'border-gray-300 hover:border-blue-400'
                      }`}
                    >
                      {emoji}
                    </button>
                  ))}
                </div>
              </div>
              
              {/* Name Input */}
              <div className="flex-1 w-full">
                <label className="block text-sm font-bold text-gray-600 mb-2">Nom du joueur</label>
                <input 
                  type="text" 
                  value={playerName}
                  onChange={(e) => setPlayerName(e.target.value)}
                  placeholder="Votre pseudo" 
                  className="w-full p-4 border-2 border-gray-300 rounded-sm font-bold text-xl outline-none focus:border-blue-600 transition-colors" 
                  maxLength={15}
                />
              </div>
            </div>
          </div>

          <div className="flex flex-col md:flex-row gap-8">
            {/* CREATE */}
            <div className="flex-1 bg-white p-6 rounded-sm border-4 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)]">
              <h3 className="text-2xl font-bold mb-4 flex items-center gap-2"><Plus size={28} /> Cr√©er une partie</h3>
              <p className="text-gray-600 mb-4">Cr√©ez votre propre salon et invitez vos amis !</p>
              <button 
                onClick={handleCreateGame} 
                disabled={isLoading}
                className={`w-full py-4 ${themeColor} text-white border-4 border-black font-bold text-xl rounded-sm btn-shadow ${themeHover} transition-all disabled:opacity-50 flex items-center justify-center gap-2`}
              >
                {isLoading ? <Loader2 className="animate-spin" size={24} /> : null}
                Cr√©er le salon
              </button>
            </div>
            
            {/* JOIN BY CODE */}
            <div className="flex-1 bg-white p-6 rounded-sm border-4 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)]">
              <h3 className="text-2xl font-bold mb-4 flex items-center gap-2"><LogIn size={28} /> Rejoindre par code</h3>
              <div className="flex gap-2 mb-4">
                <input 
                  type="text" 
                  value={joinCode}
                  onChange={(e) => setJoinCode(e.target.value.toUpperCase())}
                  placeholder="CODE" 
                  className="flex-1 p-3 border-2 border-gray-300 rounded-sm font-bold text-xl outline-none focus:border-blue-600 text-center uppercase tracking-widest" 
                  maxLength={4}
                />
                <button 
                  onClick={handleJoinGameByCode}
                  disabled={isLoading}
                  className={`px-6 ${themeColor} text-white border-2 border-black font-bold rounded-sm btn-shadow ${themeHover} disabled:opacity-50`}
                >
                  OK
                </button>
              </div>
              
              {/* Available Games List */}
              <div className="border-t-2 border-gray-200 pt-4">
                <p className="text-sm font-bold text-gray-500 mb-3">Parties disponibles</p>
                {availableGames.length === 0 ? (
                  <p className="text-center text-gray-400 py-4 italic">Aucune partie disponible</p>
                ) : (
                  <div className="space-y-2 max-h-40 overflow-y-auto">
                    {availableGames.map(game => (
                      <div key={game.roomCode} className="flex justify-between items-center p-3 border-2 border-gray-100 hover:border-blue-400 bg-gray-50 rounded-sm transition-colors">
                        <div>
                          <div className="font-bold">{game.hostName}</div>
                          <div className="text-xs text-gray-500">{game.playerCount}/{game.maxPlayers} Joueurs ‚Ä¢ {game.roomCode}</div>
                        </div>
                        <button 
                          onClick={() => handleJoinExistingGame(game.roomCode)}
                          disabled={isLoading}
                          className="px-4 py-2 bg-white border-2 border-black text-sm font-bold rounded-sm hover:bg-blue-50 disabled:opacity-50"
                        >
                          Rejoindre
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // WAITING ROOM
  return (
    <div className="min-h-screen flex flex-col items-center pt-12 px-4 bg-[#ECECEC]">
      <div className="w-full max-w-4xl bg-white rounded-sm border-4 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] overflow-hidden">
        <div className={`${themeColor} text-white p-6 border-b-4 border-black flex justify-between items-center`}>
           <button onClick={handleLeaveWaitingRoom} className="p-2 hover:bg-white/20 rounded-full" title="Quitter">
             <X size={24} />
           </button>
           <div className="text-center">
             <p className="text-sm font-bold uppercase opacity-80">Code de la partie</p>
             <button 
               onClick={copyRoomCode}
               className="text-4xl font-bold flex items-center gap-2 justify-center hover:opacity-80 transition-opacity"
               title="Copier le code"
             >
               {localRoomCode} <Copy size={20} className="opacity-70" />
             </button>
           </div>
           <div className="w-10"></div> 
        </div>

        <div className="p-8">
           <h3 className="text-2xl font-bold flex items-center gap-2 mb-6"><Users size={28} /> Joueurs ({players.length}/8)</h3>
           <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
             {players.map(player => (
               <div 
                 key={player.id} 
                 className={`flex flex-col items-center p-4 rounded-sm border-2 transition-all ${
                   player.id === 'me' 
                     ? 'bg-blue-50 border-blue-400 ring-2 ring-blue-200' 
                     : 'bg-gray-50 border-gray-200'
                 }`}
               >
                 <div className="text-5xl mb-2">{player.avatar}</div>
                 <div className="font-bold text-lg flex items-center gap-1">
                   {player.name}
                   {player.isHost && <span title="H√¥te">üëë</span>}
                 </div>
                 {player.id === 'me' && <span className="text-xs text-blue-600 font-bold">(vous)</span>}
               </div>
             ))}
             {[...Array(Math.max(0, 8 - players.length))].map((_, i) => (
                <div key={i} className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-sm opacity-50">
                  <div className="text-3xl text-gray-300">?</div>
                </div>
             ))}
           </div>
           
           <div className="flex justify-center">
              {localIsHost ? (
                <button 
                  onClick={onStartGame} 
                  disabled={players.length < 2 || isLoading}
                  className={`px-12 py-4 border-4 border-black text-2xl font-bold rounded-sm ${themeColor} text-white btn-shadow ${themeHover} flex items-center gap-3 disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                  {isLoading ? <Loader2 className="animate-spin" size={28} /> : <Play size={28} fill="currentColor" />}
                  {players.length < 2 ? 'En attente de joueurs...' : 'Lancer la partie'}
                </button>
              ) : (
                 <div className="text-center p-4 bg-yellow-50 border-2 border-[#FFD154] rounded-sm">
                   <p className="text-xl font-bold text-gray-700 animate-pulse flex items-center gap-2">
                     <Loader2 className="animate-spin" size={20} />
                     En attente de l'h√¥te...
                   </p>
                 </div>
              )}
           </div>
        </div>
      </div>
    </div>
  );
}

// DrawingScreen is now imported from './components/game/DrawingScreen'
// The old 1000+ lines implementation has been split into:
// - hooks/ : useDrawing, usePredictions, useGameTimer, useTeamSync
// - components/ : DrawingCanvas, GameHeader, TeamChat, AIFeedback
// - index.jsx : Main orchestrator component

function GameOverScreen({ drawings, gameMode = 'CLASSIC', players = [], aiScore = 0, onRestart }) {
  const canvasRef = useRef(null);
  const [timeLeft, setTimeLeft] = useState(ROUND_TIME);
  const [aiText, setAiText] = useState("Je ne vois rien pour l'instant...");
  const [isDrawing, setIsDrawing] = useState(false);
  const [hasStartedDrawing, setHasStartedDrawing] = useState(false);
  const [showQuitConfirm, setShowQuitConfirm] = useState(false);
  const [predictions, setPredictions] = useState([]);
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [receivedDrawing, setReceivedDrawing] = useState(null);
  const [roundFinished, setRoundFinished] = useState(false); // Prevent multiple finishRound calls
  const predictionTimerRef = useRef(null);
  const currentRoundRef = useRef(round); // R√©f√©rence pour tracker le round actuel
  const isPredictingRef = useRef(false); // Flag pour tracker si une pr√©diction est en cours
  const drawingSyncTimerRef = useRef(null); // Timer for syncing drawing
  const chatUnsubscribeRef = useRef(null);
  const lastDrawingRef = useRef(null); // Track last received drawing to avoid duplicate renders
  const canvasInitializedRef = useRef(false); // Track if canvas was initialized;
  const aiWonThisRoundRef = useRef(false); // Track if AI already won this round
  
  // Team mode detection
  const isTeamMode = gameMode === 'TEAM' && roomCode;
  const isDrawer = isTeamMode && currentDrawerId === playerId;
  const isViewer = isTeamMode && currentDrawerId !== playerId;
  
  // Reset when word changes (new round)
  useEffect(() => {
    currentRoundRef.current = round; // Mettre √† jour la r√©f√©rence du round
    isPredictingRef.current = false; // R√©initialiser le flag de pr√©diction
    setRoundFinished(false); // Reset round finished flag
    aiWonThisRoundRef.current = false; // Reset AI win flag for new round
    setTimeLeft(ROUND_TIME);
    setAiText("Je ne vois rien pour l'instant...");
    setHasStartedDrawing(false);
    setPredictions([]);
    setChatMessages([]); // Reset chat messages
    setChatInput('');
    setReceivedDrawing(null);
    lastDrawingRef.current = null; // Reset drawing ref for new round
    canvasInitializedRef.current = false; // Allow canvas reinit for viewers
    clearCanvas();
    
    // Clear chat in Firebase for new round (host only or drawer)
    if (isTeamMode && (isDrawer || isHost)) {
      MultiplayerService.clearChat(roomCode).catch(console.error);
    }
    
    // Annuler toute pr√©diction en attente
    if (predictionTimerRef.current) {
      clearTimeout(predictionTimerRef.current);
      predictionTimerRef.current = null;
    }
  }, [word]);

  // Subscribe to chat messages (TEAM mode)
  useEffect(() => {
    if (!isTeamMode || !roomCode) return;
    
    console.log('üí¨ Subscribing to chat for room:', roomCode);
    
    const unsubscribe = MultiplayerService.subscribeToChat(roomCode, (messages) => {
      console.log('üì® Chat messages received:', messages.length);
      setChatMessages(messages || []);
    });
    
    chatUnsubscribeRef.current = unsubscribe;
    
    return () => {
      if (chatUnsubscribeRef.current) {
        chatUnsubscribeRef.current();
        chatUnsubscribeRef.current = null;
      }
    };
  }, [isTeamMode, roomCode]);

  // Subscribe to drawing updates (TEAM mode - viewers only)
  useEffect(() => {
    // For TEAM mode, non-drawers need to subscribe to drawing updates
    const shouldSubscribe = isTeamMode && currentDrawerId && currentDrawerId !== playerId && roomCode;
    
    if (!shouldSubscribe) {
      console.log('üì∫ Not subscribing to drawing (isTeamMode:', isTeamMode, 'currentDrawerId:', currentDrawerId, 'playerId:', playerId, ')');
      return;
    }
    
    console.log('üñºÔ∏è Viewer subscribing to drawing updates for room:', roomCode);
    
    // Use dedicated drawing subscription (listens only to currentDrawing path)
    const unsubscribe = MultiplayerService.subscribeToDrawing(roomCode, (drawingData) => {
      console.log('üì° Viewer received drawing update, has data:', !!drawingData);
      
      if (drawingData && drawingData !== lastDrawingRef.current) {
        console.log('üé® New drawing data received, length:', drawingData.length);
        lastDrawingRef.current = drawingData;
        setReceivedDrawing(drawingData);
        
        // Draw received image on canvas
        if (canvasRef.current) {
          const img = new Image();
          img.onload = () => {
            console.log('üñåÔ∏è Drawing image on canvas, size:', img.width, 'x', img.height);
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            // Clear canvas with white
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw image to fill the canvas (the sender's canvas is same size)
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            console.log('‚úÖ Image drawn on viewer canvas');
          };
          img.onerror = (e) => {
            console.error('‚ùå Error loading drawing image:', e);
          };
          img.src = drawingData;
        }
      }
    });
    
    return () => unsubscribe();
  }, [isTeamMode, roomCode, currentDrawerId, playerId]);

  // Check for round end (TEAM mode)
  useEffect(() => {
    if (!isTeamMode || roundFinished) return;
    
    // Round ended by correct guess
    if (gameData?.roundStatus === 'finished' && gameData?.roundWinner) {
      // Verify we're still in the same round
      if (gameData.currentRound !== currentRoundRef.current) {
        console.log('‚ö†Ô∏è Round end ignored - round mismatch', gameData.currentRound, 'vs', currentRoundRef.current);
        return;
      }
      console.log('üèÜ Round ended! Winner:', gameData.roundWinner, 'Round:', gameData.currentRound);
      const winnerType = gameData.roundWinnerType === 'ai' ? 'AI' : 'TEAM';
      setRoundFinished(true);
      finishRound(winnerType !== 'AI', winnerType);
    }
  }, [gameData?.roundStatus, gameData?.roundWinner, gameData?.currentRound, isTeamMode, roundFinished]);

  // Timer Logic
  useEffect(() => {
    if (isPaused || timeLeft <= 0 || showQuitConfirm) {
        if (timeLeft <= 0 && !isPaused && !showQuitConfirm) {
            finishRound(false);
        }
        return;
    }

    const timer = setInterval(() => {
      setTimeLeft(prev => prev - 1);
    }, 1000);
    return () => clearInterval(timer);
  }, [timeLeft, isPaused, showQuitConfirm]);

  // AI & Team Guessing Logic - Based on real predictions (DRAWER ONLY in TEAM mode)
  useEffect(() => {
    if (!hasStartedDrawing || isPaused || showQuitConfirm || predictions.length === 0) return;
    
    // CRITICAL: Stop AI predictions when round is finished
    if (roundFinished || gameData?.roundStatus === 'finished') return;
    
    // In TEAM mode, only the drawer runs AI predictions
    if (isTeamMode && !isDrawer) return;

    // Use real predictions from the model
    const topPrediction = predictions[0]; // Meilleure pr√©diction
    const targetEnglish = FRENCH_TO_ENGLISH[word];

    if (isTeamMode && isDrawer) {
      // In Team Mode with Firebase, AI sends guesses via Firebase
      const aiGuess = topPrediction.categoryFr;
      
      // Don't send more messages if AI already won this round (use ref for immediate check)
      if (aiWonThisRoundRef.current) return;
      
      // Check if AI wins (correct prediction with enough confidence)
      const aiIsCorrect = topPrediction.category === targetEnglish && topPrediction.confidence >= 0.25;
      
      // Check if AI already sent this exact guess (avoid duplicates)
      const hasAlreadySentThisGuess = chatMessages.some(
        msg => msg.playerId === 'AI' && msg.message === aiGuess
      );
      
      if (!hasAlreadySentThisGuess && topPrediction.confidence >= 0.15) {
        // Send AI guess to Firebase chat with isCorrect flag
        MultiplayerService.sendChatMessage(roomCode, 'AI', 'ü§ñ IA', aiGuess, aiIsCorrect)
          .catch(console.error);
        
        if (aiIsCorrect) {
          console.log('ü§ñ AI guessed correctly!');
          aiWonThisRoundRef.current = true; // Mark AI as winner immediately
          // AI score is now updated in Firebase by aiGuessedCorrectly
          // All clients will receive the update via handleGameUpdate
          MultiplayerService.aiGuessedCorrectly(roomCode)
            .catch(console.error);
        }
      }
    } else if (gameMode === 'TEAM' && !isTeamMode) {
      // Local Team mode (fallback for single player test) - old logic
      const confidence = Math.round(topPrediction.confidence * 100);
      const aiGuess = topPrediction.categoryFr;
      
      const hasAlreadySentThisGuess = chatMessages.some(
        msg => msg.sender === 'AI' && msg.text === aiGuess && !msg.isCorrect
      );
      
      if (!hasAlreadySentThisGuess) {
        addLocalChatMessage('AI', aiGuess);
        
        if (topPrediction.category === targetEnglish && topPrediction.confidence >= 0.25) {
          addLocalChatMessage('AI', word, true);
          finishRound(false, 'AI');
        }
      }
    }
  }, [predictions, hasStartedDrawing, isPaused, showQuitConfirm, gameMode, word, players, chatMessages, isTeamMode, isDrawer, roomCode, roundFinished, gameData?.roundStatus]);

  // Local chat message (for non-Firebase mode)
  const addLocalChatMessage = (sender, text, isCorrect = false) => {
    setChatMessages(prev => [...prev, { id: Date.now() + Math.random(), sender, text, isCorrect }]);
  };
  
  // Send chat message (for TEAM mode guessers)
  const handleSendChatMessage = async () => {
    if (!chatInput.trim() || !isTeamMode || isDrawer) return;
    
    const message = chatInput.trim();
    const myPlayer = players.find(p => p.id === 'me');
    const playerName = myPlayer?.name || 'Joueur';
    
    // Check if correct guess
    const isCorrect = message.toLowerCase() === word.toLowerCase();
    
    setChatInput('');
    
    try {
      await MultiplayerService.sendChatMessage(roomCode, playerId, playerName, message, isCorrect);
      
      if (isCorrect) {
        console.log('üéâ You guessed correctly!');
        // The round end is handled by Firebase listener
      }
    } catch (error) {
      console.error('Error sending chat message:', error);
    }
  };
  
  // Handle Enter key in chat
  const handleChatKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendChatMessage();
    }
  };

  // Fonction pour calculer la bounding box du dessin
  const getBoundingBox = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    let minX = canvas.width;
    let minY = canvas.height;
    let maxX = 0;
    let maxY = 0;
    let hasDrawing = false;

    // Parcourir tous les pixels
    for (let y = 0; y < canvas.height; y++) {
      for (let x = 0; x < canvas.width; x++) {
        const index = (y * canvas.width + x) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];

        // D√©tecter les pixels non-blancs (dessin)
        if (r < 250 || g < 250 || b < 250) {
          hasDrawing = true;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }

    if (!hasDrawing) return null;

    // Ajouter un padding de 5%
    const width = maxX - minX;
    const height = maxY - minY;
    const padding = Math.max(width, height) * 0.05;

    return {
      x: Math.max(0, minX - padding),
      y: Math.max(0, minY - padding),
      width: Math.min(canvas.width - minX, width + padding * 2),
      height: Math.min(canvas.height - minY, height + padding * 2)
    };
  };

  // Fonction pour appliquer une dilatation morphologique (√©paississement des traits)
  const dilateImage = (ctx, width, height, iterations = 1) => {
    for (let iter = 0; iter < iterations; iter++) {
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      const output = new Uint8ClampedArray(data);

      // Kernel de dilatation 3x3
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          
          // Si le pixel actuel est noir, on passe
          if (data[idx] < 128) {
            output[idx] = data[idx];
            output[idx + 1] = data[idx + 1];
            output[idx + 2] = data[idx + 2];
            continue;
          }

          // V√©rifier les 8 voisins
          let minValue = 255;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nIdx = ((y + dy) * width + (x + dx)) * 4;
              minValue = Math.min(minValue, data[nIdx]);
            }
          }

          // Appliquer la valeur minimale (dilate les zones noires)
          output[idx] = minValue;
          output[idx + 1] = minValue;
          output[idx + 2] = minValue;
        }
      }

      // Remettre les donn√©es
      for (let i = 0; i < data.length; i++) {
        data[i] = output[i];
      }
      ctx.putImageData(imageData, 0, 0);
    }
  };

  // Fonction pour cr√©er l'image 128x128 carr√©e √† envoyer au mod√®le
  const createModelImage = () => {
    const canvas = canvasRef.current;
    const bbox = getBoundingBox();

    if (!bbox) return null;

    // Calculer le facteur de r√©duction
    const maxDimension = Math.max(bbox.width, bbox.height);
    const targetSize = 128;
    const scaleFactor = maxDimension / targetSize;

    // √âtape 1: Cr√©er un canvas interm√©diaire √† r√©solution plus √©lev√©e
    const intermediateSize = Math.max(targetSize * 2, 256);
    const intermediateCanvas = document.createElement('canvas');
    intermediateCanvas.width = intermediateSize;
    intermediateCanvas.height = intermediateSize;
    const intermediateCtx = intermediateCanvas.getContext('2d');

    // Fond blanc
    intermediateCtx.fillStyle = '#FFFFFF';
    intermediateCtx.fillRect(0, 0, intermediateSize, intermediateSize);

    // Le dessin remplit tout l'espace disponible (95% pour petite marge)
    const scale = Math.min(intermediateSize / bbox.width, intermediateSize / bbox.height) * 0.95;
    const scaledWidth = bbox.width * scale;
    const scaledHeight = bbox.height * scale;

    // Centrer le dessin
    const offsetX = (intermediateSize - scaledWidth) / 2;
    const offsetY = (intermediateSize - scaledHeight) / 2;

    // Qualit√© de redimensionnement maximale
    intermediateCtx.imageSmoothingEnabled = true;
    intermediateCtx.imageSmoothingQuality = 'high';

    // Dessiner la zone cropp√©e et redimensionn√©e sur le canvas interm√©diaire
    intermediateCtx.drawImage(
      canvas,
      bbox.x, bbox.y, bbox.width, bbox.height,
      offsetX, offsetY, scaledWidth, scaledHeight
    );

    // √âtape 2: Appliquer une dilatation si le facteur de r√©duction est √©lev√©
    if (scaleFactor > 2) {
      const dilationIterations = Math.min(Math.floor(scaleFactor / 2), 3);
      dilateImage(intermediateCtx, intermediateSize, intermediateSize, dilationIterations);
    }

    // √âtape 3: Cr√©er le canvas final 128x128
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = targetSize;
    tempCanvas.height = targetSize;
    const tempCtx = tempCanvas.getContext('2d');

    // Fond blanc
    tempCtx.fillStyle = '#FFFFFF';
    tempCtx.fillRect(0, 0, targetSize, targetSize);

    // Redimensionner du canvas interm√©diaire vers le canvas final
    tempCtx.imageSmoothingEnabled = true;
    tempCtx.imageSmoothingQuality = 'high';
    tempCtx.drawImage(intermediateCanvas, 0, 0, targetSize, targetSize);

    return tempCanvas.toDataURL('image/png');
  };

  // Real-time AI predictions avec smart crop
  const makePrediction = async () => {
    if (!canvasRef.current || isPaused || showQuitConfirm) return;
    
    // Si une pr√©diction est d√©j√† en cours, ignorer cette nouvelle requ√™te
    if (isPredictingRef.current) {
      console.log('‚è≥ Pr√©diction d√©j√† en cours, requ√™te ignor√©e');
      return;
    }
    
    // Capturer le round actuel avant de commencer la pr√©diction async
    const roundAtStart = currentRoundRef.current;
    
    try {
      isPredictingRef.current = true; // Marquer qu'une pr√©diction est en cours
      const base64Image = createModelImage();
      
      if (!base64Image) {
        isPredictingRef.current = false;
        return;
      }
      
      console.log('üì§ Envoi pr√©diction (bounding box + 128x128)...');
      
      const result = await predictDrawing(base64Image);
      
      // V√©rifier si on est toujours dans le m√™me round
      if (roundAtStart !== currentRoundRef.current) {
        console.log('‚ö†Ô∏è Pr√©diction obsol√®te ignor√©e (round chang√©)');
        isPredictingRef.current = false;
        return;
      }
      
      console.log('‚úÖ Pr√©dictions:', result.probabilities);
      
      // Transformer les pr√©dictions
      const predArray = Object.entries(result.probabilities)
        .map(([category, confidence]) => ({
          category,
          categoryFr: CATEGORY_MAP[category] || category,
          confidence
        }))
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 3);
      
      setPredictions(predArray);
      
      if (predArray.length > 0) {
        const topPrediction = predArray[0];
        const confidence = Math.round(topPrediction.confidence * 100);
        setAiText(`Je vois... ${topPrediction.categoryFr} (${confidence}%)`);
        
        const targetEnglish = FRENCH_TO_ENGLISH[word];
        
        // Debug: afficher les valeurs pour comprendre le probl√®me
        console.log('üîç Debug - word:', word, '‚Üí targetEnglish:', targetEnglish);
        console.log('üîç Debug - categories re√ßues:', predArray.map(p => p.category));
        
        // V√©rifier si le mot cible est dans le top 3
        const isInTop3 = predArray.some(pred => pred.category === targetEnglish);
        const targetPrediction = predArray.find(pred => pred.category === targetEnglish);
        
        if (isInTop3) {
          const targetConfidence = Math.round(targetPrediction.confidence * 100);
          const position = predArray.findIndex(pred => pred.category === targetEnglish) + 1;
          console.log(`üéØ ${targetEnglish} trouv√© en position ${position} avec ${targetConfidence}%`);
        } else {
          console.log(`‚ùå ${targetEnglish} PAS trouv√© dans le top 3`);
        }
        
        // Gagner si le mot cible est dans le top 3 avec confiance >= 25%
        // En mode TEAM, ne PAS appeler finishRound ici - c'est g√©r√© par aiGuessedCorrectly et le useEffect
        if (isInTop3 && targetPrediction && targetPrediction.confidence >= 0.25 && !isTeamMode) {
          console.log('‚úÖ BONNE R√âPONSE! (Top 3)');
          isPredictingRef.current = false; // Lib√©rer le flag avant de finir le round
          const capturedRound = currentRoundRef.current;
          setTimeout(() => {
            // Ne finir que si on est toujours dans le m√™me round
            if (currentRoundRef.current === capturedRound) {
              finishRound(true);
            } else {
              console.log('‚ö†Ô∏è setTimeout finishRound ignor√© - round chang√©');
            }
          }, 500);
          return; // Sortir imm√©diatement
        }
      }
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      setAiText("Erreur de pr√©diction...");
    } finally {
      isPredictingRef.current = false; // Toujours lib√©rer le flag
    }
  };

  // Les pr√©dictions se font uniquement lors du dessin via le debounce
  // (pas d'interval automatique pour √©viter le rate limiting)

  const finishRound = (success, winner = null) => {
    // Prevent multiple calls
    if (roundFinished) return;
    setRoundFinished(true);
    
    // Get top prediction confidence for scoring
    const topConfidence = predictions.length > 0 ? predictions[0].confidence : 0;
    
    // Utiliser l'image avec bounding box au lieu du canvas complet
    let imageData = createModelImage();
    
    // Si pas de dessin (canvas vide), cr√©er une image placeholder
    if (!imageData) {
      const emptyCanvas = document.createElement('canvas');
      emptyCanvas.width = 128;
      emptyCanvas.height = 128;
      const ctx = emptyCanvas.getContext('2d');
      
      // Fond gris clair
      ctx.fillStyle = '#F3F4F6';
      ctx.fillRect(0, 0, 128, 128);
      
      // Texte "Pas de dessin"
      ctx.fillStyle = '#9CA3AF';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Pas de', 64, 54);
      ctx.fillText('dessin', 64, 74);
      
      imageData = emptyCanvas.toDataURL('image/png');
    }
    
    onComplete(imageData, success, winner, timeLeft, topConfidence);
  };

  // Drawing Handlers - avec scaling pour canvas plein √©cran
  const getCoordinates = (event) => {
    if (!canvasRef.current) return { x: 0, y: 0 };
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    // Support mouse et touch
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    // Le canvas CSS peut √™tre grand √©cran, mais r√©solution interne = 280x280
    // On scale les coordonn√©es pour correspondre √† la r√©solution interne
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;
    
    return { x, y };
  };

  const startDraw = (e) => {
    // Block drawing for viewers in TEAM mode
    if (isPaused || showQuitConfirm || isViewer) return;
    e.preventDefault();
    const { x, y } = getCoordinates(e);
    const ctx = canvasRef.current.getContext('2d');
    // Commencer un nouveau chemin
    ctx.beginPath();
    ctx.moveTo(x, y);
    setIsDrawing(true);
    setHasStartedDrawing(true);
  };

  const draw = (e) => {
    // Block drawing for viewers in TEAM mode
    if (!isDrawing || isPaused || showQuitConfirm || isViewer) return;
    e.preventDefault();
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const currentPos = getCoordinates(e);
    
    // Dessiner une ligne continue
    ctx.lineTo(currentPos.x, currentPos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(currentPos.x, currentPos.y);
    
    // Debounced prediction - pendant le dessin (500ms)
    if (predictionTimerRef.current) {
      clearTimeout(predictionTimerRef.current);
    }
    predictionTimerRef.current = setTimeout(() => {
      makePrediction();
      
      // Sync drawing to Firebase (TEAM mode drawer)
      if (isTeamMode && isDrawer) {
        syncDrawingToFirebase();
      }
    }, 500);
  };

  const stopDraw = () => {
    setIsDrawing(false);
    // Faire une pr√©diction imm√©diate quand on arr√™te de dessiner
    if (hasStartedDrawing && !isPaused && !showQuitConfirm && !isViewer) {
      setTimeout(() => {
        makePrediction();
        // Sync drawing when stopping (TEAM mode drawer)
        if (isTeamMode && isDrawer) {
          syncDrawingToFirebase();
        }
      }, 100);
    }
  };

  // Sync drawing to Firebase (TEAM mode)
  const syncDrawingToFirebase = () => {
    if (!canvasRef.current || !roomCode) return;
    
    // Throttle syncing to avoid too many updates
    if (drawingSyncTimerRef.current) {
      clearTimeout(drawingSyncTimerRef.current);
    }
    
    drawingSyncTimerRef.current = setTimeout(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      const dataUrl = canvas.toDataURL('image/png', 0.5); // Compress for faster sync
      console.log('üì§ Syncing drawing to Firebase, length:', dataUrl.length);
      MultiplayerService.updateDrawingData(roomCode, dataUrl)
        .then(() => console.log('‚úÖ Drawing synced'))
        .catch(err => console.error('‚ùå Error syncing drawing:', err));
    }, 100);
  };

  const clearCanvas = () => {
    if (!canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    // Fond blanc
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    setHasStartedDrawing(false);
    setPredictions([]);
    setAiText("Je ne vois rien pour l'instant...");
  };

  // Configuration du canvas plein √©cran
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Determine if this player is a viewer (not the drawer in TEAM mode)
    const isCurrentViewer = isTeamMode && currentDrawerId && currentDrawerId !== playerId;
    
    // For viewers, just set the size once - don't clear
    if (isCurrentViewer) {
      if (!canvasInitializedRef.current) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        canvasInitializedRef.current = true;
        console.log('üìê Viewer canvas initialized:', canvas.width, 'x', canvas.height);
      }
      return; // Don't add resize listener for viewers
    }

    // Taille plein √©cran (drawer only)
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    // Resize handler (drawer only)
    const handleResize = () => {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.putImageData(imageData, 0, 0);
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isTeamMode, currentDrawerId, playerId, round]); // Re-run when drawer changes or when round changes

  return (
    <div className="flex h-screen bg-white overflow-hidden">
      {/* LEADERBOARD (RACE MODE ONLY) */}
      {gameMode === 'RACE' && (
        <div className="w-80 bg-gray-50 border-r-2 border-gray-200 flex flex-col z-20 shadow-lg shrink-0">
          <div className="p-3 bg-blue-600 border-b-2 border-blue-700 font-bold text-white flex items-center gap-2">
            <Zap size={18} /> Classement en direct
          </div>
          <div className="flex-1 overflow-y-auto p-4">
            <div className="space-y-3">
              {players.map((player, idx) => (
                <div 
                  key={player.id}
                  className={`flex items-center gap-3 p-3 rounded-lg border-2 transition-all ${
                    player.id === 'me' 
                      ? 'bg-blue-50 border-blue-300 shadow-sm' 
                      : 'bg-white border-gray-200'
                  }`}
                >
                  <div className="text-2xl font-bold text-gray-400 w-8">#{idx + 1}</div>
                  <div className="text-3xl">{player.avatar}</div>
                  <div className="flex-1">
                    <div className="font-bold text-lg">{player.name}</div>
                    <div className="text-sm text-gray-500">{player.score} pts</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      <div className="flex flex-col flex-1 overflow-hidden">
        {/* QUIT CONFIRMATION MODAL */}
        {showQuitConfirm && (
          <div className="fixed inset-0 z-[60] bg-black/50 flex items-center justify-center p-4">
              <div className="bg-white border-4 border-black p-8 rounded-sm shadow-lg max-w-sm w-full text-center">
                  <AlertTriangle className="mx-auto mb-4 text-blue-600" size={48} />
                  <h3 className="text-2xl font-bold mb-2">Quitter la partie ?</h3>
                  <p className="text-gray-600 mb-8">Votre progression sera perdue.</p>
                  <div className="flex gap-4">
                      <button 
                          onClick={() => setShowQuitConfirm(false)}
                          className="flex-1 py-3 font-bold border-2 border-gray-300 hover:bg-gray-100 rounded-sm"
                      >
                          Annuler
                      </button>
                      <button 
                          onClick={onQuit}
                          className="flex-1 py-3 font-bold bg-blue-600 text-white border-2 border-black rounded-sm btn-shadow hover:bg-blue-500"
                      >
                          Quitter
                      </button>
                  </div>
              </div>
          </div>
        )}

        {/* Header */}
        <div className="flex justify-between items-center px-4 py-3 bg-[#ECECEC] z-10 shrink-0 border-b border-gray-200">
          <div className="text-lg md:text-xl">
            {isTeamMode ? (
              // Team mode with Firebase
              <>
                <span className="text-blue-600 font-bold">üë• √âquipe {players.reduce((sum, p) => sum + (p.score || 0), 0)}</span>
                <span className="mx-2">vs</span>
                <span className="text-red-600 font-bold">ü§ñ IA {globalAiScore}</span>
                {isDrawer && (
                  <span className="ml-4 text-purple-600 font-bold">
                    Dessinez : <span className="capitalize">{word}</span>
                  </span>
                )}
              </>
            ) : gameMode === 'TEAM' ? (
              // Local team mode (fallback) - m√™me calcul que Firebase mode
              <>
                <span className="text-blue-600 font-bold">üë• √âquipe {players.reduce((sum, p) => sum + (p.score || 0), 0)}</span>
                <span className="mx-2">vs</span>
                <span className="text-red-600 font-bold">ü§ñ IA {globalAiScore}</span>
              </>
            ) : (
              <>
                <span className="text-gray-400">Dessinez : </span>
                <span className="font-bold capitalize">{word}</span>
              </>
            )}
          </div>
          <div className="text-3xl md:text-4xl font-bold text-gray-700">
            00:{timeLeft < 10 ? `0${timeLeft}` : timeLeft}
          </div>
        </div>

        {/* Main Drawing Area */}
        <div className={`flex-1 relative bg-white overflow-hidden ${isViewer ? 'cursor-default' : 'cursor-crosshair'}`}>
          <canvas
            ref={canvasRef}
            className={`absolute inset-0 touch-none ${isViewer ? 'pointer-events-none' : ''}`}
            onMouseDown={startDraw}
            onMouseMove={draw}
            onMouseUp={stopDraw}
            onMouseLeave={stopDraw}
            onTouchStart={startDraw}
            onTouchMove={draw}
            onTouchEnd={stopDraw}
          />
          
          {/* Viewer overlay - show who is drawing */}
          {isViewer && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-purple-100 border-2 border-purple-300 px-4 py-2 rounded-full shadow-lg z-10">
              <span className="text-purple-700 font-bold">
                {players.find(p => p.id === currentDrawerId || (currentDrawerId === playerId && p.id === 'me'))?.name || 'Un joueur'} dessine...
              </span>
            </div>
          )}
          
          {/* AI Voice Overlay with Predictions - Only for Classic/Race modes */}
          {gameMode !== 'TEAM' && (
            <div className="absolute bottom-4 left-0 right-0 flex flex-col items-center gap-2 pointer-events-none px-4">
              <p className="text-xl md:text-2xl bg-white/90 inline-block px-4 py-2 rounded-lg text-gray-800 font-bold transition-all duration-300 shadow-lg border-2 border-gray-200">
                {aiText}
              </p>
              
              {/* Top 3 Predictions */}
              {predictions.length > 0 && (
                <div className="flex gap-2 flex-wrap justify-center">
                  {predictions.map((pred, idx) => {
                    const confidence = Math.round(pred.confidence * 100);
                    const isCorrect = pred.category === FRENCH_TO_ENGLISH[word];
                    return (
                      <div 
                        key={idx}
                        className={`px-3 py-1 rounded-full text-sm font-bold transition-all duration-300 ${
                          isCorrect 
                            ? 'bg-green-500 text-white border-2 border-green-700 scale-110' 
                            : confidence >= 70 
                              ? 'bg-yellow-100 text-yellow-800 border border-yellow-300' 
                              : 'bg-gray-100 text-gray-600 border border-gray-300'
                        }`}
                      >
                        {pred.categoryFr} {confidence}%
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}
        </div>

        {/* Footer Controls */}
        <div className="bg-[#ECECEC] px-4 py-2 flex justify-between items-center border-t border-gray-200 shrink-0">
          {/* Clear button - only for drawer or non-team modes */}
          {!isViewer ? (
            <button 
                onClick={clearCanvas} 
                className="p-2 hover:bg-gray-200 rounded-full transition-colors flex flex-col items-center gap-1 group" 
                title="Effacer"
            >
              <Trash2 size={24} className="text-gray-600 group-hover:text-black" />
              <span className="text-xs font-bold text-gray-500 group-hover:text-black">Effacer</span>
            </button>
          ) : (
            <div className="w-16"></div>
          )}
          
          <div className="flex gap-4">
               {/* Skip Button - Masqu√© en mode Race et Team */}
              {gameMode !== 'RACE' && gameMode !== 'TEAM' && (
                <button 
                    onClick={() => finishRound(false)} 
                    className="flex items-center gap-2 p-2 hover:bg-gray-200 rounded-full transition-colors group"
                    title="Passer"
                >
                    <SkipForward size={28} className="text-gray-600 group-hover:text-black" />
                </button>
              )}
          </div>

          <button 
              onClick={() => setShowQuitConfirm(true)} 
              className="p-2 hover:bg-gray-200 rounded-full transition-colors group" 
              title="Quitter"
          >
            <X size={28} className="text-gray-600 group-hover:text-red-500" />
          </button>
        </div>
      </div>

      {/* CHAT SIDEBAR (TEAM MODE ONLY) */}
      {gameMode === 'TEAM' && (
        <div className="w-80 bg-gray-50 border-l-2 border-gray-200 flex flex-col z-20 shadow-lg shrink-0">
           <div className="p-3 bg-white border-b-2 border-gray-100 font-bold text-gray-500 flex items-center gap-2">
             <MessageSquare size={18} /> Chat de l'√©quipe
             {isDrawer && <span className="text-xs bg-purple-100 text-purple-600 px-2 py-1 rounded-full ml-auto">Vous dessinez</span>}
           </div>
           <div className="flex-1 overflow-y-auto p-4 space-y-3 flex flex-col-reverse scrollbar-hide">
              {/* Messages reversed to start from bottom */}
              {[...chatMessages].reverse().map(msg => {
                // Support both Firebase format (playerId, playerName, message) and local format (sender, text)
                const isAI = msg.playerId === 'AI' || msg.sender === 'AI';
                const senderName = msg.playerName || msg.sender || 'Joueur';
                const messageText = msg.message || msg.text || '';
                const isMe = msg.playerId === playerId;
                
                return (
                  <div key={msg.id} className={`flex flex-col animate-in slide-in-from-bottom-2 ${isAI ? 'items-end' : isMe ? 'items-end' : 'items-start'}`}>
                    <div className="text-xs text-gray-400 mb-1 font-bold">
                      {isAI ? 'ü§ñ IA' : isMe ? '‚ú® Vous' : senderName}
                    </div>
                    <div className={`px-3 py-2 rounded-lg max-w-[90%] text-sm font-medium shadow-sm border 
                        ${msg.isCorrect 
                           ? 'bg-green-500 text-white border-green-600 scale-110 origin-bottom' 
                           : isAI 
                             ? 'bg-red-50 text-red-900 border-red-100' 
                             : isMe 
                               ? 'bg-blue-50 text-blue-900 border-blue-100'
                               : 'bg-white text-gray-800 border-gray-200'}
                    `}>
                       {msg.isCorrect ? `‚òÖ ${messageText.toUpperCase()} !` : messageText}
                    </div>
                  </div>
                );
              })}
              {chatMessages.length === 0 && <div className="text-center text-gray-300 italic mt-10">La partie commence...</div>}
           </div>
           <div className="p-3 bg-white border-t-2 border-gray-200">
             {isDrawer ? (
               // Drawer can't chat
               <div className="flex items-center gap-2 bg-gray-100 rounded-full px-3 py-2 opacity-50 cursor-not-allowed">
                 <input type="text" disabled placeholder="Vous dessinez..." className="bg-transparent flex-1 outline-none text-sm" />
                 <Send size={16} />
               </div>
             ) : (
               // Guessers can send messages
               <div className="flex items-center gap-2 bg-white border-2 border-gray-200 rounded-full px-3 py-2 focus-within:border-blue-400 transition-colors">
                 <input 
                   type="text" 
                   value={chatInput}
                   onChange={(e) => setChatInput(e.target.value)}
                   onKeyPress={handleChatKeyPress}
                   placeholder="Proposez une r√©ponse..." 
                   className="bg-transparent flex-1 outline-none text-sm"
                   autoComplete="off"
                 />
                 <button 
                   onClick={handleSendChatMessage}
                   disabled={!chatInput.trim()}
                   className={`p-1 rounded-full transition-colors ${chatInput.trim() ? 'text-blue-600 hover:bg-blue-50' : 'text-gray-300'}`}
                 >
                   <Send size={18} />
                 </button>
               </div>
             )}
           </div>
        </div>
      )}
    </div>
  );
}

function GameOverScreen({ drawings, gameMode = 'CLASSIC', players = [], aiScore = 0, onRestart }) {
  // Calculate winner message
  const getWinnerMessage = () => {
    if (gameMode === 'RACE') {
      const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
      const winner = sortedPlayers[0];
      if (winner.id === 'me') {
        return {
          text: "F√©licitations ! Vous avez gagn√© !",
          color: "text-green-600"
        };
      } else {
        return {
          text: `${winner.name} a gagn√© la course !`,
          color: "text-blue-600"
        };
      }
    } else if (gameMode === 'TEAM') {
      // Score √©quipe : somme des scores de tous les joueurs
      const teamScore = players.reduce((sum, p) => sum + (p.score || 0), 0);
      // Score IA : pass√© en prop depuis le parent
      
      if (teamScore > aiScore) {
        return {
          text: "L'√©quipe a gagn√© ! Bravo !",
          color: "text-green-600"
        };
      } else if (aiScore > teamScore) {
        return {
          text: "L'IA a gagn√© cette fois...",
          color: "text-red-600"
        };
      } else {
        return {
          text: "√âgalit√© parfaite !",
          color: "text-yellow-600"
        };
      }
    }
    return null;
  };

  const winnerMessage = getWinnerMessage();
  const successCount = drawings.filter(d => d.success).length;

  return (
    <div className="min-h-screen bg-[#ECECEC] p-4 md:p-8 flex flex-col items-center">
      <h1 className="text-4xl md:text-5xl font-bold mb-2 mt-4 text-center">Partie termin√©e !</h1>
      
      {/* Winner Message */}
      {winnerMessage && (
        <p className={`text-3xl font-bold mb-4 ${winnerMessage.color}`}>
          {winnerMessage.text}
        </p>
      )}
      
      {/* Score Display */}
      {gameMode === 'CLASSIC' && (
        <p className="text-xl mb-12 text-gray-600">
          Score : {successCount}/{drawings.length}
        </p>
      )}

      {/* Race Mode Leaderboard */}
      {gameMode === 'RACE' && (
        <div className="w-full max-w-2xl mb-8 bg-white rounded-sm border-4 border-black shadow-lg p-6">
          <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
            <Zap size={24} className="text-blue-600" /> Classement Final
          </h2>
          <div className="space-y-3">
            {[...players].sort((a, b) => b.score - a.score).map((player, idx) => (
              <div 
                key={player.id}
                className={`flex items-center gap-4 p-4 rounded-lg border-2 ${
                  player.id === 'me' 
                    ? 'bg-blue-50 border-blue-300 shadow-md' 
                    : 'bg-gray-50 border-gray-200'
                }`}
              >
                <div className="text-3xl font-bold text-gray-400 w-12">#{idx + 1}</div>
                <div className="text-4xl">{player.avatar}</div>
                <div className="flex-1">
                  <div className="font-bold text-xl">{player.name}</div>
                </div>
                <div className="text-2xl font-bold text-blue-600">{player.score} pts</div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Team vs AI Score */}
      {gameMode === 'TEAM' && (
        <div className="w-full max-w-2xl mb-8 bg-white rounded-sm border-4 border-black shadow-lg p-6">
          <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
            <Users size={24} className="text-blue-600" /> Score Final
          </h2>
          <div className="flex justify-around items-center">
            <div className="text-center">
              <div className="text-5xl mb-2">üë•</div>
              <div className="text-lg font-bold text-gray-600">√âquipe</div>
              <div className="text-4xl font-bold text-blue-600">
                {players.reduce((sum, p) => sum + (p.score || 0), 0)}
              </div>
            </div>
            <div className="text-5xl font-bold text-gray-300">VS</div>
            <div className="text-center">
              <div className="text-5xl mb-2">ü§ñ</div>
              <div className="text-lg font-bold text-gray-600">IA</div>
              <div className="text-4xl font-bold text-red-600">
                {aiScore}
              </div>
            </div>
          </div>
        </div>
      )}

      <p className="text-xl mb-8 text-gray-600">Voici vos chefs-d'≈ìuvre</p>

      {/* Drawings Grid */}
      <div className="grid grid-cols-2 md:grid-cols-3 gap-6 max-w-4xl w-full mb-12">
        {drawings.map((draw, idx) => (
          <div key={idx} className="bg-white rounded-sm shadow-md overflow-hidden relative border-2 border-gray-300">
            <div className="aspect-square relative bg-gray-50 p-4">
               <img src={draw.imageData} alt={draw.word} className="w-full h-full object-contain" />
               {/* Success/Fail indicator en haut √† droite */}
               <div className={`absolute top-2 right-2 w-10 h-10 rounded-full flex items-center justify-center ${
                 draw.success ? 'bg-green-500' : 'bg-red-500'
               }`}>
                 {draw.success ? (
                   <span className="text-white text-2xl font-bold">‚úì</span>
                 ) : (
                   <span className="text-white text-2xl font-bold">‚úó</span>
                 )}
               </div>
            </div>
            <div className={`p-3 text-center border-t-2 ${
              draw.success ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200'
            }`}>
              <p className="font-bold text-gray-800 capitalize text-base">{draw.word}</p>
            </div>
          </div>
        ))}
      </div>

      <div className="flex flex-col md:flex-row gap-6 mb-16 w-full max-w-lg justify-center">
        <button 
           className="btn-shadow flex-1 bg-[#3b5998] text-white border-2 border-black py-3 px-6 text-xl rounded-sm flex items-center justify-center gap-2 hover:opacity-90 transition-opacity"
        >
          <Share2 size={20} /> Partager
        </button>
        <button 
          className="btn-shadow flex-1 bg-[#00aced] text-white border-2 border-black py-3 px-6 text-xl rounded-sm flex items-center justify-center gap-2 hover:opacity-90 transition-opacity"
        >
          <Share2 size={20} /> Tweeter
        </button>
      </div>

      <button 
        onClick={onRestart}
        className="btn-shadow bg-blue-600 text-white border-4 border-black text-2xl px-12 py-4 rounded-sm hover:bg-blue-500 transition-colors font-bold mb-20 flex items-center gap-3"
      >
        <RefreshCw size={24} /> Rejouer
      </button>
    </div>
  );
}